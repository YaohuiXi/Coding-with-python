* 剑指6、从尾到头打印链表
方法一：递归
```python
class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        # write code here
        self.head = listNode
        cur = self.head
        print(self.travel(self,cur))

    def travel(self,cur):
        if not cur:
            return []
        return self.printListFromTailToHead(cur.next) + [cur.val]
```

方法二，用栈的方式，每次在list第一位插入一个节点
```python
    def travel(self):
        l = []
        if not self.head:
            return []
        cur = self.head
        while cur:
            l.insert(0, cur.val)
            cur = cur.next
        return l
```
方法三，从头到尾读，然后然后进行数组翻转
```python
    def travel(self):
        l = []
        if not self.head:
            return []
        else:
            cur = self.head
            while cur:
                l.append(cur.val)
                cur = cur.next
        result = []
        n = len(l)
        for i in range(n - 1, -1, -1):
            result.append(l[i])
        return result
 ```
 
* LeetCode 83、从有序链表中删除重复节点（保留一个）
```python
class ListNode():
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def deleteDuplicates(self, head):
        # 空链表或者只有一个元素的链表
        if head == None or head.next == None:
            return head
        new_head = head
        while head != None and head.next != None:
            if head.val == head.next.val:
                head.next = head.next.next
            else:
                head = head.next
        return new_head
 ```
* 剑指18、删除链表的节点（不保留）
 ```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head
        pre = dummy
        cur = head
        while(cur is not None):
            if cur.next is not None and cur.next.val == cur.val:
                val = cur.val
                while(cur is not None and val == cur.val):
                    cur = cur.next
                pre.next = cur
            else:
                pre = pre.next
                cur = cur.next
        return dummy.next
 ```

* 剑指22、链表中倒数第k个节点
 ```python
class Solution:
    def FindKthToTail(self, head, k):
        # write code here
        if head is None:
            return head
        i = 0
        tmp = head
        while i< k:
            i+=1
            if tmp is None:
                return None
            else:
                tmp = tmp.next 
        k = head
        while tmp is not None:
            tmp = tmp.next
            k = k.next
        return k
 ``` 
* 剑指23、链表中环的入口节点
 ```python
class Solution:
    def EntryNodeOfLoop(self, pHead):
        # write code here
        fast,slow = pHead,pHead
        while(fast is not None and fast.next is not None):
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                p = pHead
                while (p!=slow):
                    p = p.next
                    slow = slow.next
                return slow
        return None
 ```
* 剑指24、反转链表
 ```python
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        # write code here
        pre = None
        cur = pHead
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre
 ```
* 剑指25、合并两个排序的链表
 ```python
class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        # write code here
        if pHead1 ==None and pHead2 ==None:
            return None
        if pHead1 == None:
            return pHead2
        if pHead2 == None:
            return pHead1
        
        if(pHead1.val<pHead2.val):
            cur = pHead1
            p = pHead1.next
            q = pHead2
        else:
            cur = pHead2
            p = pHead1
            q = pHead2.next
        head = cur
        
        while (p!=None and q!=None):
            if(p.val>q.val):
                cur.next = q
                cur = q
                q = q.next
            else:
                cur.next = p
                cur = p
                p = p.next
        if(q!=None):
            cur.next = q
        else:
            cur.next = p
        return head   
 ```
* 剑指35、复杂链表的复制
* 剑指36、二叉搜索树与双向链表
* 剑指52、两个链表的第一个公共节点
 ```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        l1,l2 = headA,headB
        while(l1!=l2):
            if l1:
                l1 = l1.next
            else:
                l1 = headB
            if l2:
                l2 = l2.next
            else:
                l2 = headA
        return l1
 ```
* 剑指62、圆圈中最后剩下的数字

* LeetCode 24、交换链表中的相邻结点

* LeetCode 445、链表求和
* LeetCode 234、回文链表
* LeetCode 725、分隔链表
* LeetCode 328、链表元素按照奇偶聚合


