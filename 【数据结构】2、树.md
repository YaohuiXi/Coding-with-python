## 树的高度
* 剑指offer55、二叉树的深度
```python
class Solution:
    def maxDepth(self,root):
        if root is None:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```
* LeetCode 110、平衡树
暴力解（时间复杂度 O(Nlog2N)，空间复杂度O(N)）
```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        left_height = self.get_height(root.left)
        right_height = self.get_height(root.right)
        if abs(left_height-right_height) > 1:
            return False
        return self.isBalanced(root.left) and self.isBalanced(root.right)

    def get_height(self,root):
        if not root:
            return 0
        l = self.get_height(root.left)
        r = self.get_height(root.right)
        return max(l,r)+1
```
优化解（时间复杂度 O(N)，空间复杂度O(N)）
```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        return self.recur(root) != -1

    def recur(self, root):
        if not root:
            return 0
        left = self.recur(root.left)
        if left == -1:
            return -1
        right = self.recur(root.right)
        if right == -1:
            return -1
        return max(left, right) + 1 if abs(left - right) < 2 else -1
```
* LeetCode 543、两节点的最长路径
* LeetCode 111、最小路径

## 对称
* LeetCode 226、翻转树
```python
class Solution(object):
	def invertTree(self, root):
		if not root:
			return None
		root.left,root.right = root.right,root.left
		self.invertTree(root.left)
		self.invertTree(root.right)
		return root
```
* LeetCode 101、树的对称
```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if root is None:
            return True
        return self.Symmetric(root.left, root.right)

    def Symmetric(self, l, r):
        if (l is None) and (r is None):
            return True
        if (l is None) or (r is None):
            return False
        if l.val != r.val:
            return False
        return self.Symmetric(l.left, r.right) and self.Symmetric(l.right, r.left)
```
* 剑指offer27、二叉树的镜像
* 剑指offer28、对称的二叉树

## 路径
* LeetCode 437、统计路径和等于一个数的路径数量
* 剑指offer34、二叉树和为某一值的路径

## 子结构/子树
* 剑指offer26、树的子结构
```python
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        # write code here
        if not pRoot1 or not pRoot2:
            return False
        return self.issub(pRoot1,pRoot2) or self.HasSubtree(pRoot1.left,pRoot2) or self.HasSubtree(pRoot1.right,pRoot2)
    
    def issub(self,pRoot1,pRoot2):
        if not pRoot2:
            return True
        if not pRoot1 or pRoot1.val!=pRoot2.val:
            return False
       #left=self.issub(pRoot1.left,pRoot2.left)
       # right=self.issub(pRoot1.right,pRoot2.right)
        return self.issub(pRoot1.left,pRoot2.left) and self.issub(pRoot1.right,pRoot2.right)
```
* LeetCode 572 子树
```python
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        if not s:
            return False
        return self.isSubtreeWithRoot(s,t) or self.isSubtree(s.left,t) or self.isSubtree(s.right,t)

    def isSubtreeWithRoot(self,s,t):
        if (s is None) and (t is None):
            return True
        if (s is None) or (t is None):
            return False
        # if s.val != t.val:
            # return False
        return s.val == t.val and self.isSubtreeWithRoot(s.left,t.left) and self.isSubtreeWithRoot(s.right,t.right)
```
## 其他
* LeetCode 617 归并两棵树
* LeetCode 404 统计左叶子节点的和
* LeetCode 687 相同节点值的最大路径长度
* 剑指offer37、序列化二叉树

## 树的祖先
* LeetCode 235 二叉查找树的最近公共祖先
```python
class Solution:
    def lowestCommonAncestor(self, root, p, q):
        parent_val = root.val
        p_val = p.val
        q_val = q.val

        if p_val > parent_val and q_val > parent_val:    
            return self.lowestCommonAncestor(root.right, p, q)
        elif p_val < parent_val and q_val < parent_val:    
            return self.lowestCommonAncestor(root.left, p, q)
        else:
            return root
```
* 剑指offer68、树中两个节点的最低公共祖先
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root: 
            return root
        if root is p or root is q: 
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        ## 如果分别属于左边和右边，则返回根节点
        if left and right: 
            return root
        # 如果没有左边，也就是全部属于右边，返回右边，以root.right为根的树，继续递归
        if not left: 
            return right
        if not right: 
            return left
```
## 树的遍历（前序、中序、后续、层次）
前序
```python  
# 前序遍历-迭代
    def preorderTraversal(self, root):
        result = []
        stack = [root]
        while stack:
            node = stack.pop()
            if node:
                result.append(node.val)
                stack.append(node.right)
                stack.append(node.left)
        return result

# 前序遍历-递归
    def preorderTraversal(self, root):
        res = []
        self.helper(root,res)
        return res

    def helper(self,root,res):
        if not root:
            return res
        res.append(root.val)
        self.helper(root.left,res)
        self.helper(root.right,res)
        return res
```

```python
# 中序遍历-迭代 左根右
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        stack = []
        node = root
        while stack or node:
            # 从根一路找到最左边的节点，依次放入栈中
            if node:
                stack.append(node)
                node = node.left
            # 从栈顶开始pop，寻找右节点是否有元素，有的话放入栈中
            else:
                node = stack.pop()
                # print(node.val)
                result.append(node.val)
                # 注意这边不需要判断右节点是否为空，为空直接返回上面的else分支，然后pop栈
                # 判断了则会错误
                node = node.right
        return result

# 中序遍历-递归
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        self.result = []
        self.inorder(root)
        return self.result
    def inorder(self,root):
        if not root:
            return
        self.inorder(root.left)
        self.result.append(root.val)
        self.inorder(root.right)
```
```python
# 后序遍历-迭代
# 先反过来，根右左遍历（同前序），然后再反转
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        stack1 = [root]
        stack2 = []
        result = []
        while stack1:
            node = stack1.pop()
            if node:
                stack2.append(node.val)
                stack1.append(node.left)
                stack1.append(node.right)
        while stack2:
            result.append(stack2.pop())
        return result


# 后序遍历-递归
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        self.result = []
        self.postorder(root)
        return self.result

    def postorder(self,root):
        if not root:
            return
        self.postorder(root.left)
        self.postorder(root.right)
        self.result.append(root.val)
```
* 剑指offer7、重建二叉树
* 剑指offer8、二叉树的下一个节点（中序遍历）
* 剑指offer32、从上到下打印树

## 中序解决二叉搜索树问题
* 二叉搜索树的最小绝对差
* 二叉搜索树中第k小的元素
* 剑指offer54、二叉搜索树的第k大节点
* 二叉搜索树中的众数
* 二叉搜索树的范围和
* 两数之和IV-输入BST
* 验证二叉搜索树
https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/solution/zhong-xu-bian-li-tuan-mie-xi-lie-er-cha-sou-suo-sh/

## 二叉搜索树的性质
* 剑指offer33、二叉搜索树的后序遍历序列
```python   
class Solution:
    def VerifySquenceOfBST(self, sequence):
        # write code here
        if len(sequence) == 0:
            return False
        return self.check(sequence,0,len(sequence)-1)
    
    def check(self,arr,start,end):
        if start>=end:
            return True
        # 后续遍历，最后一个是根
        root = arr[end]
        end = end - 1
        while(end >=0 and arr[end]>root):
            end -= 1
        mid = end + 1
        for i in range(start,mid):
            if arr[i] > root:
                return False
        # print(end)
        return self.check(arr,start,mid-1) and self.check(arr,mid,end)
```   
* 剑指offer36、二叉搜索树与双向链表
```python
class Solution:
    def Convert(self, pRootOfTree):
        # write code here
        if pRootOfTree is None:
            return None
        stack = []
        cur = pRootOfTree
        prev = None
        head = None
        while(True):
            while(cur is not None):
                stack.append(cur)
                cur = cur.left
            if len(stack) == 0:
                break
            cur = stack.pop()
            if prev is None:
                cur.left = None
                head = cur
            else:
                prev.right = cur
                cur.left = prev
            prev = cur
            cur = cur.right
        return head
```

## Trie树
