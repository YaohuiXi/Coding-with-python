## 树的高度
* 剑指offer55、二叉树的深度
* LeetCode 110、平衡树
* LeetCode 543、两节点的最长路径
* LeetCode 111、最小路径

## 对称
* LeetCode 226、翻转树
* LeetCode 101、树的对称
* 剑指offer27、二叉树的镜像
* 剑指offer28、对称的二叉树

## 路径
* LeetCode 437、统计路径和等于一个数的路径数量
* 剑指offer34、二叉树和为某一值的路径

## 子结构/子树
* 剑指offer26、树的子结构
* LeetCode 572 子树

## 其他
* LeetCode 617 归并两棵树
* LeetCode 404 统计左叶子节点的和
* LeetCode 687 相同节点值的最大路径长度
* 剑指offer37、序列化二叉树

## 树的祖先
* LeetCode 235 二叉查找树的最近公共祖先
* 剑指offer68、树中两个节点的最低公共祖先

## 树的遍历（前序、中序、后续、层次）
前序
```python  
# 前序遍历-迭代
    def preorderTraversal(self, root):
        result = []
        stack = [root]
        while stack:
            node = stack.pop()
            if node:
                result.append(node.val)
                stack.append(node.right)
                stack.append(node.left)
        return result

# 前序遍历-递归
    def preorderTraversal(self, root):
        res = []
        self.helper(root,res)
        return res

    def helper(self,root,res):
        if not root:
            return res
        res.append(root.val)
        self.helper(root.left,res)
        self.helper(root.right,res)
        return res
```

```python
# 中序遍历-迭代 左根右
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        stack = []
        node = root
        while stack or node:
            # 从根一路找到最左边的节点，依次放入栈中
            if node:
                stack.append(node)
                node = node.left
            # 从栈顶开始pop，寻找右节点是否有元素，有的话放入栈中
            else:
                node = stack.pop()
                # print(node.val)
                result.append(node.val)
                # 注意这边不需要判断右节点是否为空，为空直接返回上面的else分支，然后pop栈
                # 判断了则会错误
                node = node.right
        return result

# 中序遍历-递归
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        self.result = []
        self.inorder(root)
        return self.result
    def inorder(self,root):
        if not root:
            return
        self.inorder(root.left)
        self.result.append(root.val)
        self.inorder(root.right)
```
```python
# 后序遍历-迭代
# 先反过来，根右左遍历（同前序），然后再反转
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        stack1 = [root]
        stack2 = []
        result = []
        while stack1:
            node = stack1.pop()
            if node:
                stack2.append(node.val)
                stack1.append(node.left)
                stack1.append(node.right)
        while stack2:
            result.append(stack2.pop())
        return result


# 后序遍历-递归
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        self.result = []
        self.postorder(root)
        return self.result

    def postorder(self,root):
        if not root:
            return
        self.postorder(root.left)
        self.postorder(root.right)
        self.result.append(root.val)
```
* 剑指offer7、重建二叉树
* 剑指offer8、二叉树的下一个节点（中序遍历）
* 剑指offer32、从上到下打印树

## 中序解决二叉搜索树问题
* 二叉搜索树的最小绝对差
* 二叉搜索树中第k小的元素
* 剑指offer54、二叉搜索树的第k大节点
* 二叉搜索树中的众数
* 二叉搜索树的范围和
* 两数之和IV-输入BST
* 验证二叉搜索树
https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/solution/zhong-xu-bian-li-tuan-mie-xi-lie-er-cha-sou-suo-sh/

## 二叉搜索树的性质
* 剑指offer33、二叉搜索树的后序遍历序列
```python   
class Solution:
    def VerifySquenceOfBST(self, sequence):
        # write code here
        if len(sequence) == 0:
            return False
        return self.check(sequence,0,len(sequence)-1)
    
    def check(self,arr,start,end):
        if start>=end:
            return True
        # 后续遍历，最后一个是根
        root = arr[end]
        end = end - 1
        while(end >=0 and arr[end]>root):
            end -= 1
        mid = end + 1
        for i in range(start,mid):
            if arr[i] > root:
                return False
        # print(end)
        return self.check(arr,start,mid-1) and self.check(arr,mid,end)
```   
* 剑指offer36、二叉搜索树与双向链表
```python
class Solution:
    def Convert(self, pRootOfTree):
        # write code here
        if pRootOfTree is None:
            return None
        stack = []
        cur = pRootOfTree
        prev = None
        head = None
        while(True):
            while(cur is not None):
                stack.append(cur)
                cur = cur.left
            if len(stack) == 0:
                break
            cur = stack.pop()
            if prev is None:
                cur.left = None
                head = cur
            else:
                prev.right = cur
                cur.left = prev
            prev = cur
            cur = cur.right
        return head
```

## Trie树
